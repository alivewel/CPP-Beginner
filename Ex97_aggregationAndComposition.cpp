#include <iostream>
#include <string>
using namespace std;

/*
*    јгрегаци€ и композици€. ќтношени€ между классами и объектами.
*/

class Cap {
public:
    string GetColor() {
        return color;
    }
private:
    string color = "red";
};


class Human {
public:
    void Think() {
        brain.Think();
    }
    void InspectTheCap() {
        cout << "ћо€ кепка " << cap.GetColor() << "  цвета" << endl;
    }
private:
    class Brain {
    public:
        void Think() {
            cout << "я думаю!" << endl;
        }
    };
    Brain brain;
    Cap cap;
};

int main() { 
    setlocale(LC_ALL, "Russian");

    Human human;
    human.Think();
    human.InspectTheCap();

    return 0; 
}

// создадим класс Human и внутри него вложенный класс Brain
// создадим внутри класса экземпл€р класса Brain
// ” нас есть метод Think() в классах Human и Brain
// теперь мы можем внутри метода Brain в классе Human использовать метод Think из класса Brain

// человек без мозга думать не может. ѕока мы не создадим объект класса Brain, то есть пока не создадим метод Think (думать)
// использовать метод Think в классе Human мы не можем
// описываема€ ситуаци€ называетс€ делегирование. Ёто один из паттернов проектировани€.

// когда в классе Human описан класс Brain
// » когда класс Brain без класса Human сущестовать не может
// если мы уничтожаем класс Human, то и класс Brain тоже уничтожаетс€.
// этот пример называетс€ композицией

// создадим класс Cap (кепка)
// создадим объект класса Cap внутри класса Human
// класс Cap никоем образом не св€зан с классом Human и может существовать спокойно без него
// напишем внутри класса Human метод, который будет взаимодействовать с классом Cap
// этот пример называетс€ агрегацией

// отличие между агрегацией и композицией в том, что в одном случае (композици€) вложенный класс не может сущестовать без основного.
// а во втором случае (агрегаци€) класс может существовать спокойно без него
