#include <iostream>
#include <string>
using namespace std;

class Apple {

public:
    Apple (int weight, string color) {
        this->weight = weight;
        this->color = weight;
        count++;
    }
    static int GetCount() {
        // this->weight = weight; // нельзя в статическом методе обращаться к нестатическим полям
        // weight = 10; // тоже нельзя
        return count;
    }
    static void ChangeColor(Apple &apple, string color) {
        apple.color = color;
    }
private:
    int weight;
    string color;
    static int count; // перенесли в секцию private
};

int Apple::count = 0;

int main() { 
    setlocale(LC_ALL, "ru");
    Apple apple(150, "red");
    Apple apple2(100, "green");
    Apple apple3(200, "yellow");

    std::cout << Apple::GetCount() << std::endl; // так можно 
    std::cout << apple.GetCount() << std::endl; // так тоже можно

    apple.ChangeColor(apple, "Green"); // изменим цвет через статический метод

    return 0; 
}

// поведение статичекских методов похоже на статические поля
// в предыдущем примере ex92 статическое поле класса было public.
// Это проблема, это нарушает принцип инкапсуляции и логику программы.
// Мы можем обращаться к нашему полю count и менять его значение.
// Если мы поменяет его значение, то количество созданных объектов класса будет выводится не верно. А ведь именно для этого мы создали эту переменную.
// Это поле необходимо сделать private.
// После этого нам нужно как-то узнавать значение этого статического поля. Для этого нам нужен статический паблик метод.

// в статическом методе можно обращаться только статическим полям
// в статическом методе нельзя использовать ключевое слово this
// потому что так мы будем обращаться к текущему экземпляру класса,
// статический метод не относиться ни к какому конкретному объекту
// в статическом методе обычные поля как-то использовать тоже не можем.

// в статическом методе можно обращаться к нестатическим полям,
// если указать в аргументы функции
// указатель на опредленный объект класса